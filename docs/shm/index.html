<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#a9384a">
    <meta name="referrer" content="no-referrer">
    <meta name="description"
        name="The personal website of Maurice Frank. Information about my work, music and services.">

    
    
    <link rel="stylesheet" href="https://morris-frank.dev/sass/main.0823c09806485e7148fd0d17ae0f2d2c3209b388e9c30d98ae25deeeeef0e08c.css">
    <link rel="shortcut icon" type="image/png" href="/icon.png" />

    
    <script async src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js"></script>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/katex.min.css"
        integrity="sha384-ThssJ7YtjywV52Gj4JE/1SQEDoMEckXyhkFVwaf4nDSm5OBlXeedVYjuuUd0Yua+" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/katex.min.js"
        integrity="sha384-Bi8OWqMXO1ta+a4EPkZv7bYGIes7C3krGSZoTGNTAnAn5eYQc7IIXrJ/7ck1drAi"
        crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.3/dist/contrib/auto-render.min.js"
        integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css"
        integrity="sha256-BPfK9M5v34c2XP6p0cxVz1mUQLst0gTLk0mlc7kuodA=" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"
        integrity="sha256-yDc0eil8GjWFKqN1OSzHSVCiuGghTosZCcRje4tj7iQ=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.5.1/gpx.min.js" crossorigin="anonymous"></script>

    <title> Persistant shared memory - Morris-Frank </title>
</head>

<body>
    <header class="center">
        <h1>
            <a href="https://morris-frank.dev">Morris-Frank</a>
        </h1>
        <a href="https://morris-frank.dev/projects">projects</a>
        <a href="https://morris-frank.dev/tutorials">tutorials</a>
        <a href="https://github.com/morris-frank/resume/raw/master/Frank_cv.pdf">cv</a>
        <a href="https://morris-frank.dev/services">hire me</a>
    </header>

    <nav id="toc"></nav>

    <main class="center">
        <h2>Persistant shared memory</h2>


<p>How to create a store in memory easily share and survive restarts etc… in pure Python</p>


<hr/>


<div class="tags">
  
    
    <span>Python</span>
  
</div>


<p>For a data visualization project at my current employer we need a way to save big data matrices in-memory and access them from random processes. On the server mulitple <a href="https://dash.plotly.com/">DASH</a> dashboards are hosted, with which you can build nice web data viz dashboards while staying purely in Python. The data displayed in the dashboards where consisting of matrices, each up to 5GB big. As the dashboards are, of course, multi-user and a also randomly shutting down and up and also are running by different users on the system, if you would just access the pickled numpy files on the hard drive, when needed, you would be constantly loading data which takes forever.</p>
<h3 id="usage-of-_shared_memory_">Usage of <em>shared_memory</em></h3>
<p>Therefore we are using the <a href="https://docs.python.org/3/library/multiprocessing.shared_memory.html">Shared memory</a> module from the <code>multiprocessing</code> package in the standard library to load those big matrices into the shared memory (SHM), from where they then can loaded by the different processes.</p>
<p>Basic usage of the module is fairly simple, as shown below. You create a numpy array which is buffered in the <em>named</em> shared memory. Then in another process you can access the matrix, by opening the shared memory by its name. Here shown, basic <em>SET</em> and <em>GET</em> methods:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">shared_memory</span>

<span class="k">def</span> <span class="nf">set_shared_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
    <span class="n">shm</span> <span class="o">=</span> <span class="n">shared_memory</span><span class="o">.</span><span class="n">SharedMemory</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">matrix</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)</span>
    <span class="n">Xshm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">shm</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span>
    <span class="n">Xshm</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:]</span>
    <span class="k">return</span> <span class="n">XShm</span>

<span class="k">def</span> <span class="nf">get_shared_matrix</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">shm</span> <span class="o">=</span> <span class="n">shared_memory</span><span class="o">.</span><span class="n">SharedMemory</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">shm</span><span class="o">.</span><span class="n">buf</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</code></pre></div><p>Moving a matrix into memory then looks like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1_000</span><span class="p">,</span> <span class="mi">1_000</span><span class="p">)</span>

<span class="n">set_shared_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="s2">&#34;my_shared_matrix&#34;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="s2">&#34;/dev/shm/my_shared_matrix&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">())</span>
<span class="c1"># True</span>
</code></pre></div><p>And retrieving it:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">matrix</span> <span class="o">=</span> <span class="n">get_shared_matrix</span><span class="p">(</span><span class="s2">&#34;my_shared_matrix)</span>
</code></pre></div><p>The problem with this approach is, that Python will keep track of who (or how many) processes are accessing a named shared memory item. If that counter goes to zero, the item is deleted from memory. It should be fairly obvious that this is a sensible approach, as if you would not do that, you would block memory with data that is un-connected to any process and if you then do not keep track of it menually, you will eventually leak memory.</p>
<h3 id="making-it-permanent">Making it permanent</h3>
<p>Well, we don&rsquo;t care about those risks! We want <em>really persistant</em> shared memory. This can be accomplished by a simple hack.</p>
<p>The singleton that keeps track of the shared memory items is a <code>ResourceTracker</code> object, also defined in <code>multiprocessing</code>. The method used to register a new object in the registry is the <code>register</code> method:</p>
<p><strong>Source code:</strong> <a href="https://github.com/python/cpython/blob/3.10/Lib/multiprocessing/resource_tracker.py">Lib/multiprocessing/shared_memory.py</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rtype</span><span class="p">):</span>
    <span class="s1">&#39;&#39;&#39;Register name of resource with resource tracker.&#39;&#39;&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_send</span><span class="p">(</span><span class="s1">&#39;REGISTER&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rtype</span><span class="p">)</span>
</code></pre></div><p>So to hack that method, we load the singleton <code>resource_tracker</code> in our code before setting any <code>SharedMemory</code> matrices and hot-patch it to not register <code>shared_memory</code> items:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">resource_tracker</span>

<span class="k">def</span> <span class="nf">__resource_register_patch</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rtype</span> <span class="o">!=</span> <span class="s2">&#34;shared_memory&#34;</span><span class="p">:</span>
        <span class="n">resource_tracker</span><span class="o">.</span><span class="n">_resource_tracker</span><span class="o">.</span><span class="n">_send</span><span class="p">(</span><span class="s2">&#34;REGISTER&#34;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rtype</span><span class="p">)</span>

<span class="n">resource_tracker</span><span class="o">.</span><span class="n">register</span> <span class="o">=</span> <span class="n">__resource_register_patch</span>
</code></pre></div><p>Now if you use the <code>set_shared_matrix()</code> function from above, the matrix is set in shared memory and stays there indefinitely! So you can even kill all Python processes, start a new one with a different user and you will find the same matrix under the same name!</p>
<h3 id="quickly-clearing-the-shared-memory">Quickly clearing the Shared Memory</h3>
<p>In practice, we definitly made mistakes and started leaking dead memory into SHM. So quickly you will ask yourself how can I quickly and easily get rid of all those matrices? Luckily, on Linux the shared memory is mounted as a file system and you can find it under <code>/dev/shm</code>. In that folder you will find your shared memory matrices as files with the filename being the name you set when saving them.</p>
<p>So you can easily clear the whole thing by doing in the shell:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">rm /dev/shm/*
</code></pre></div><p>Probably you want to only delete your Python shared memory objects, so in our code we made it a rule that the names of the <code>SharedMemory</code> buffers should all end in <code>.shm</code>. So then to clean only those we just do:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">rm /dev/shm/*shm
</code></pre></div><p>All of this is a quite the hack, but you know what, it works… And you do not need to install any additional packages, so that is pretty cool.</p>

    </main>

    <footer>
        <div class="center box flex">
            <div>
                <h2>Contact</h2>
                <p>Maurice Frank</p>
                <p class="icon-mail-alt">firstname.lastname @ posteo de</p>
                <p class="icon-code"><a href="https://github.com/morris-frank/morris-frank.dev">source code (MIT)</a>
                </p>
            </div>
            <div>
                <h2>Privacy statement</h2>
                <p>I don't collect any data from you. Neither do I want any data. So don't send me any!</p>
            </div>
        </div>
    </footer>

    <script> window.addEventListener('load', function () { var lazyLoadInstance = new LazyLoad({}); }, false);</script>
    <script>
        const toc_items = document.querySelectorAll("h3");
        if (toc_items.length > 0) {
            let inner = "<ul>";
            toc_items.forEach(item => {
                inner += "<li><a href=\"#" + item.id + "\">" + item.innerText + "</a></li>";
            });
            toc.innerHTML = inner + "</ul>";
        }
    </script>

</body>

</html>