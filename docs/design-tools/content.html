<style type="text/css">
    .hue-sliders {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 2rem;
        margin-bottom: 5rem;

        &>div {
            display: grid;
            grid-template-areas:
                "title number"
                "slider slider";
            grid-template-columns: 1fr max-content;
            gap: 1rem;

            label {
                grid-area: title;
                font-size: 1.2rem;
                font-weight: 600;
            }

            input[type="number"] {
                grid-area: number;
                width: 4rem;
                padding: 0.25rem;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 0.875rem;
            }

            input[type="range"] {
                grid-area: slider;
                -webkit-appearance: none;
                width: 100%;
                height: 20px;
                border-radius: 10px;
                background: linear-gradient(to right,
                        oklch(80% 0.24 0),
                        oklch(80% 0.24 60),
                        oklch(80% 0.24 120),
                        oklch(80% 0.24 180),
                        oklch(80% 0.24 240),
                        oklch(80% 0.24 300),
                        oklch(80% 0.24 360));
                outline: none;
                /* transition: opacity .2s; */
            }


            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 13px;
                height: 13px;
                background: var(--black);
                border-radius: 50%;
                cursor: pointer;
                box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            }

            input[type="range"]::-moz-range-thumb {
                width: 13px;
                height: 13px;
                background: var(--black);
                cursor: pointer;
                box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            }
        }
    }

    pre {
        display: flex;
        justify-content: space-between;
        gap: 0.2rem;
        margin: 0;
        cursor: pointer;
        color: gray;
        mix-blend-mode: luminosity;
        padding: 0.25rem 0.5rem;
        border-radius: 2px;
        background: rgba(255, 255, 255, 0.2);
        font-size: 0.5rem;
        overflow: scroll;
        max-width: 100%;

        &:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        &::after {
            content: "ðŸ“‹";
            font-size: 0.4rem;
        }

        &.copied::after {
            content: "âœ“";
        }

    }

    #lightColorSchemeCode,
    #darkColorSchemeCode {
        max-height: 15rem;
        overflow: scroll;
        margin: 0 auto;
    }


    section {
        padding: 1rem;
        border-radius: 8px;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        min-width: 0;
        overflow: scroll;

        h3 {
            margin: 0;
            font-size: 0.7rem;
            text-wrap: nowrap;
            color: gray;
            mix-blend-mode: luminosity;
        }
    }
</style>

<h2>Material Design 3 Color Scheme Generator</h2>

<div class="hue-sliders">
    <div>
        <label>Primary</label>
        <input type="number" data-state="primary" min="0" max="360" oninput="setState('primary', this.value)">
        <input type="range" data-state="primary" min="0" max="360" oninput="setState('primary', this.value)">
    </div>
    <div>
        <label>Secondary</label>
        <input type="number" data-state="secondary" min="0" max="360" oninput="setState('secondary', this.value)">
        <input type="range" data-state="secondary" min="0" max="360" oninput="setState('secondary', this.value)">
    </div>
    <div>
        <label>Tertiary</label>
        <input type="number" data-state="tertiary" min="0" max="360" oninput="setState('tertiary', this.value)">
        <input type="range" data-state="tertiary" min="0" max="360" oninput="setState('tertiary', this.value)">
    </div>
</div>

<div id="lightColorScheme" style="display: grid; grid-template-columns: 1fr 200px; gap: 2rem;">
    <main style="display: flex; flex-direction: row; gap: 2rem;">
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
            <div>
                <section class="primary"></section>
                <section class="onPrimary"></section>
            </div>
            <div>
                <section class="secondary"></section>
                <section class="onSecondary"></section>
            </div>
            <div>
                <section class="tertiary"></section>
                <section class="onTertiary"></section>
            </div>
        </div>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
            <div>
                <section class="primaryContainer"></section>
                <section class="onPrimaryContainer"></section>
            </div>
            <div>
                <section class="secondaryContainer"></section>
                <section class="onSecondaryContainer"></section>
            </div>
            <div>
                <section class="tertiaryContainer"></section>
                <section class="onTertiaryContainer"></section>
            </div>
        </div>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
            <div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                    <section class="primaryFixed"></section>
                    <section class="primaryFixedDim"></section>
                </div>
                <section class="onPrimaryFixed"></section>
                <section class="onPrimaryFixedVariant"></section>
            </div>
            <div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                    <section class="secondaryFixed"></section>
                    <section class="secondaryFixedDim"></section>
                </div>
                <section class="onSecondaryFixed"></section>
                <section class="onSecondaryFixedVariant"></section>
            </div>
            <div></div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                <section class="tertiaryFixed"></section>
                <section class="tertiaryFixedDim"></section>
            </div>
            <section class="onTertiaryFixed"></section>
            <section class="onTertiaryFixedVariant"></section>
        </div>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr);">
            <section class="surfaceDim"></section>
            <section class="surface"></section>
            <section class="surfaceBright"></section>
        </div>
        <div style="display: grid; grid-template-columns: repeat(5, 1fr);">
            <section class="surfaceContainerLowest"></section>
            <section class="surfaceContainerLow"></section>
            <section class="surfaceContainer"></section>
            <section class="surfaceContainerHigh"></section>
            <section class="surfaceContainerHighest"></section>
        </div>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr);">
            <section class="onSurface"></section>
            <section class="onSurfaceVariant"></section>
            <section class="outline"></section>
            <section class="outlineVariant"></section>
        </div>
    </main>
    <aside style="display: flex; flex-direction: row; justify-content: space-between;">
        <div style="display: flex; flex-direction: row;  gap: 1rem;">
            <div>
                <section class="error"></section>
                <section class="onError"></section>
            </div>
            <div>
                <section class="errorContainer"></section>
                <section class="onErrorContainer"></section>
            </div>
        </div>

        <div style="display: flex; flex-direction: row; gap: 2rem;">
            <div>
                <section class="inverseSurface"></section>
                <section class="inverseOnSurface"></section>
                <section class="inversePrimary"></section>
            </div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                <section class="scrim"></section>
                <section class="shadow"></section>
            </div>
        </div>
    </aside>
</div>


<div id="darkColorScheme" style="display: grid; grid-template-columns: 1fr 200px; gap: 2rem;">
    <main style="display: flex; flex-direction: row; gap: 2rem;">
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
            <div>
                <section class="primary"></section>
                <section class="onPrimary"></section>
            </div>
            <div>
                <section class="secondary"></section>
                <section class="onSecondary"></section>
            </div>
            <div>
                <section class="tertiary"></section>
                <section class="onTertiary"></section>
            </div>
        </div>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
            <div>
                <section class="primaryContainer"></section>
                <section class="onPrimaryContainer"></section>
            </div>
            <div>
                <section class="secondaryContainer"></section>
                <section class="onSecondaryContainer"></section>
            </div>
            <div>
                <section class="tertiaryContainer"></section>
                <section class="onTertiaryContainer"></section>
            </div>
        </div>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
            <div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                    <section class="primaryFixed"></section>
                    <section class="primaryFixedDim"></section>
                </div>
                <section class="onPrimaryFixed"></section>
                <section class="onPrimaryFixedVariant"></section>
            </div>
            <div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                    <section class="secondaryFixed"></section>
                    <section class="secondaryFixedDim"></section>
                </div>
                <section class="onSecondaryFixed"></section>
                <section class="onSecondaryFixedVariant"></section>
            </div>
            <div></div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                <section class="tertiaryFixed"></section>
                <section class="tertiaryFixedDim"></section>
            </div>
            <section class="onTertiaryFixed"></section>
            <section class="onTertiaryFixedVariant"></section>
        </div>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr);">
            <section class="surfaceDim"></section>
            <section class="surface"></section>
            <section class="surfaceBright"></section>
        </div>
        <div style="display: grid; grid-template-columns: repeat(5, 1fr);">
            <section class="surfaceContainerLowest"></section>
            <section class="surfaceContainerLow"></section>
            <section class="surfaceContainer"></section>
            <section class="surfaceContainerHigh"></section>
            <section class="surfaceContainerHighest"></section>
        </div>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr);">
            <section class="onSurface"></section>
            <section class="onSurfaceVariant"></section>
            <section class="outline"></section>
            <section class="outlineVariant"></section>
        </div>
    </main>
    <aside style="display: flex; flex-direction: row; justify-content: space-between;">
        <div style="display: flex; flex-direction: row;  gap: 1rem;">
            <div>
                <section class="error"></section>
                <section class="onError"></section>
            </div>
            <div>
                <section class="errorContainer"></section>
                <section class="onErrorContainer"></section>
            </div>
        </div>

        <div style="display: flex; flex-direction: row; gap: 2rem;">
            <div>
                <section class="inverseSurface"></section>
                <section class="inverseOnSurface"></section>
                <section class="inversePrimary"></section>
            </div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                <section class="scrim"></section>
                <section class="shadow"></section>
            </div>
        </div>
    </aside>
</div>

<h2>Flutter Code</h2>
<div style="display: flex; gap: 2rem; justify-content: center;">
    <pre id="lightColorSchemeCode"></pre>
    <pre id="darkColorSchemeCode"></pre>
</div>



<script>
    const getContrastColor = (l, c, h) => {
        const adjustedL = l > 50 ? Math.max(0, l - 20) : Math.min(100, l + 20);
        return { l: adjustedL, c, h };
    }

    const hueDiff = (h, diff) => {
        const newHue = h + diff;
        if (newHue > 360) return newHue - 360;
        if (newHue < 0) return newHue + 360;
        return newHue;
    }

    function oklchToHex(l, c, h) {
        // Normalize percentages to required ranges
        const normalizedL = l / 100; // Convert 0-100 to 0-1
        const normalizedC = (c / 100) * 0.4; // Convert 0-100 to 0-0.4

        // Convert OKLCH to OKLAB
        const a_oklab = normalizedC ? normalizedC * Math.cos((h / 180) * Math.PI) : 0;
        const b_oklab = normalizedC ? normalizedC * Math.sin((h / 180) * Math.PI) : 0;

        const L = Math.pow(
            normalizedL * 0.99999999845051981432 +
            0.39633779217376785678 * a_oklab +
            0.21580375806075880339 * b_oklab,
            3
        );
        const M = Math.pow(
            normalizedL * 1.0000000088817607767 -
            0.1055613423236563494 * a_oklab -
            0.063854174771705903402 * b_oklab,
            3
        );
        const S = Math.pow(
            normalizedL * 1.0000000546724109177 -
            0.089484182094965759684 * a_oklab -
            1.2914855378640917399 * b_oklab,
            3
        );

        const Rx = +4.076741661347994 * L -
            3.307711590408193 * M +
            0.230969928729428 * S;
        const Gx = -1.2684380040921763 * L +
            2.6097574006633715 * M -
            0.3413193963102197 * S;
        const Bx = -0.004196086541837188 * L -
            0.7034186144594493 * M +
            1.7076147009309444 * S;

        const lrgb_fn = (val = 0) => {
            const abs = Math.abs(val);
            if (abs > 0.0031308) {
                return (Math.sign(val) || 1) * (1.055 * Math.pow(abs, 1 / 2.4) - 0.055);
            }
            return val * 12.92;
        };

        const R = (lrgb_fn(Rx));
        const G = (lrgb_fn(Gx));
        const B = (lrgb_fn(Bx));

        const toHex = (n) => {
            const hex = Math.round(Math.max(0, Math.min(255, n * 255))).toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        };

        return `${toHex(R)}${toHex(G)}${toHex(B)}`;
    }

    const state = new Proxy({}, {
        set(target, prop, value) {
            target[prop] = value;

            document.querySelectorAll(`[data-state="${prop}"]`).forEach(element => {
                element.value = value;
            });

            createSchemes();

            return true;
        }
    });

    function setState(key, value) {
        if (typeof value === 'string') {
            value = parseInt(value);
            if (isNaN(value)) value = 0;
        }
        value = Math.max(0, Math.min(360, value));
        state[key] = value;
    }

    setState('primary', 53);
    setState('secondary', 106);
    setState('tertiary', 24);

    async function copyToClipboard(text) {
        try {
            await navigator.clipboard.writeText(text);
            return true;
        } catch (err) {
            console.error('Failed to copy:', err);
            return false;
        }
    }

    function updateColor(scheme, name, l, c, h) {
        const oklchStr = `oklch(${l}% ${c}% ${h})`;
        const hexStr = oklchToHex(l, c, h);

        document.getElementById('lightColorSchemeCode').innerHTML += `  ${name}: Color(0xff${hexStr}),\n`;
        document.getElementById('darkColorSchemeCode').innerHTML += `  ${name}: Color(0xff${hexStr}),\n`;

        const card = document.querySelector(`#${scheme}ColorScheme .${name}`);
        card.style.backgroundColor = oklchStr;
        card.style.color = getContrastColor(l, c, h);
        card.innerHTML = `
            <h3>${name}</h3>
            <pre>${oklchStr}</pre>
            <pre>${hexStr}</pre>
        `;
    }


    function createSchemes() {
        const primary = state.primary;
        const secondary = state.secondary;
        const tertiary = state.tertiary;
        if (primary === null || primary === undefined ||
            secondary === null || secondary === undefined ||
            tertiary === null || tertiary === undefined) {
            return;
        }
        document.getElementById('lightColorSchemeCode').innerHTML = 'const kLightScheme = ColorScheme(\n  brightness: Brightness.light,\n  surfaceTint: Colors.transparent,\n';
        document.getElementById('darkColorSchemeCode').innerHTML = 'const kDarkScheme = ColorScheme(\n  brightness: Brightness.dark,\n  surfaceTint: Colors.transparent,\n';

        updateColor('light', 'primary', 74, 43, primary);
        updateColor('light', 'secondary', 74, 38, secondary);
        updateColor('light', 'tertiary', 74, 38, tertiary);
        updateColor('light', 'onPrimary', 24, 0, hueDiff(primary, 90 - 53));
        updateColor('light', 'onSecondary', 24, 0, hueDiff(secondary, 90 - 106));
        updateColor('light', 'onTertiary', 24, 0, hueDiff(tertiary, 90 - 24));

        updateColor('light', 'primaryContainer', 81, 22, primary);
        updateColor('light', 'secondaryContainer', 95, 2, secondary);
        updateColor('light', 'tertiaryContainer', 82, 26, tertiary);
        updateColor('light', 'onPrimaryContainer', 44, 29, hueDiff(primary, 50 - 53));
        updateColor('light', 'onSecondaryContainer', 24, 0, hueDiff(secondary, 90 - 106));
        updateColor('light', 'onTertiaryContainer', 44, 29, hueDiff(tertiary, 24 - 24));

        updateColor('light', 'primaryFixed', 92, 11, hueDiff(primary, 5));
        updateColor('light', 'secondaryFixed', 92, 11, hueDiff(secondary, 5));
        updateColor('light', 'tertiaryFixed', 92, 11, hueDiff(tertiary, 5));
        updateColor('light', 'primaryFixedDim', 83, 26, hueDiff(primary, 3));
        updateColor('light', 'secondaryFixedDim', 83, 11, hueDiff(secondary, 3));
        updateColor('light', 'tertiaryFixedDim', 83, 33, hueDiff(tertiary, 3));
        updateColor('light', 'onPrimaryFixed', 23, 24, hueDiff(primary, -5));
        updateColor('light', 'onSecondaryFixed', 23, 14, hueDiff(secondary, -5));
        updateColor('light', 'onTertiaryFixed', 23, 32, hueDiff(tertiary, -5));
        updateColor('light', 'onPrimaryFixedVariant', 40, 24, hueDiff(primary, 1));
        updateColor('light', 'onSecondaryFixedVariant', 40, 8, hueDiff(secondary, 1));
        updateColor('light', 'onTertiaryFixedVariant', 40, 32, hueDiff(tertiary, 1));

        updateColor('light', 'surfaceDim', 89, 3, 85);
        updateColor('light', 'surface', 100, 0, 90);
        updateColor('light', 'surfaceBright', 100, 0, 90);

        updateColor('light', 'surfaceContainerLowest', 99, 3, 78);
        updateColor('light', 'surfaceContainerLow', 99, 1, 85);
        updateColor('light', 'surfaceContainer', 97, 1, 91);
        updateColor('light', 'surfaceContainerHigh', 94, 1.3, 67.76);
        updateColor('light', 'surfaceContainerHighest', 92, 4, 85);

        updateColor('light', 'onSurface', 24, 0, 90);
        updateColor('light', 'onSurfaceVariant', 82, 1, 78);
        updateColor('light', 'outline', 80, 6, 101);
        updateColor('light', 'outlineVariant', 83, 5, 101);

        updateColor('light', 'error', 51, 48, 33);
        updateColor('light', 'onError', 100, 0, 68);
        updateColor('light', 'errorContainer', 92, 11, 25);
        updateColor('light', 'onErrorContainer', 41, 28, 28);

        updateColor('light', 'inverseSurface', 31, 3, 303);
        updateColor('light', 'inverseOnSurface', 96, 3, 303);
        updateColor('light', 'inversePrimary', 84, 23, hueDiff(primary, 3));

        updateColor('light', 'shadow', 0, 0, 0);
        updateColor('light', 'scrim', 0, 0, 0);


        updateColor('dark', 'primary', 86, 43, primary);
        updateColor('dark', 'secondary', 86, 38, secondary);
        updateColor('dark', 'tertiary', 86, 38, tertiary);
        updateColor('dark', 'onPrimary', 24, 0, hueDiff(primary, 90 - 53));
        updateColor('dark', 'onSecondary', 24, 0, hueDiff(secondary, 90 - 106));
        updateColor('dark', 'onTertiary', 24, 0, hueDiff(tertiary, 90 - 24));

        updateColor('dark', 'primaryContainer', 41, 22, primary);
        updateColor('dark', 'secondaryContainer', 40, 2, secondary);
        updateColor('dark', 'tertiaryContainer', 40, 26, tertiary);
        updateColor('dark', 'onPrimaryContainer', 81, 29, hueDiff(primary, 50 - 53));
        updateColor('dark', 'onSecondaryContainer', 95, 0, hueDiff(secondary, 90 - 106));
        updateColor('dark', 'onTertiaryContainer', 82, 29, hueDiff(tertiary, 24 - 24));

        updateColor('dark', 'primaryFixed', 92, 11, hueDiff(primary, 5));
        updateColor('dark', 'secondaryFixed', 92, 11, hueDiff(secondary, 5));
        updateColor('dark', 'tertiaryFixed', 92, 11, hueDiff(tertiary, 5));
        updateColor('dark', 'primaryFixedDim', 83, 26, hueDiff(primary, 3));
        updateColor('dark', 'secondaryFixedDim', 83, 11, hueDiff(secondary, 3));
        updateColor('dark', 'tertiaryFixedDim', 83, 33, hueDiff(tertiary, 3));
        updateColor('dark', 'onPrimaryFixed', 23, 24, hueDiff(primary, -5));
        updateColor('dark', 'onSecondaryFixed', 23, 14, hueDiff(secondary, -5));
        updateColor('dark', 'onTertiaryFixed', 23, 32, hueDiff(tertiary, -5));
        updateColor('dark', 'onPrimaryFixedVariant', 40, 24, hueDiff(primary, 1));
        updateColor('dark', 'onSecondaryFixedVariant', 40, 8, hueDiff(secondary, 1));
        updateColor('dark', 'onTertiaryFixedVariant', 40, 32, hueDiff(tertiary, 1));

        updateColor('dark', 'surfaceDim', 19, 3, 85);
        updateColor('dark', 'surface', 24, 0, 90);
        updateColor('dark', 'surfaceBright', 35, 3, 90);

        updateColor('dark', 'surfaceContainerLowest', 16, 3, 78);
        updateColor('dark', 'surfaceContainerLow', 23, 2, 85);
        updateColor('dark', 'surfaceContainer', 24, 3, 91);
        updateColor('dark', 'surfaceContainerHigh', 29, 3, 67.76);
        updateColor('dark', 'surfaceContainerHighest', 33, 3, 85);

        updateColor('dark', 'onSurface', 95, 0, hueDiff(primary, 4));
        updateColor('dark', 'onSurfaceVariant', 92, 4, hueDiff(primary, -10));
        updateColor('dark', 'outline', 60, 6, 101);
        updateColor('dark', 'outlineVariant', 40, 5, 101);

        updateColor('dark', 'error', 51, 48, 33);
        updateColor('dark', 'onError', 100, 0, 68);
        updateColor('dark', 'errorContainer', 92, 11, 25);
        updateColor('dark', 'onErrorContainer', 41, 28, 28);

        updateColor('dark', 'inverseSurface', 96, 3, 303);
        updateColor('dark', 'inverseOnSurface', 31, 3, 303);
        updateColor('dark', 'inversePrimary', 50, 23, hueDiff(primary, 3));

        updateColor('dark', 'shadow', 0, 0, 0);
        updateColor('dark', 'scrim', 0, 0, 0);


        document.getElementById('lightColorSchemeCode').innerHTML += ');';
        document.getElementById('darkColorSchemeCode').innerHTML += ');';

        document.querySelectorAll('pre').forEach(el => {
            el.addEventListener('click', async () => {
                const success = await copyToClipboard(el.textContent);
                if (success) {
                    el.classList.add('copied');
                    setTimeout(() => el.classList.remove('copied'), 1500);
                }
            });
        });
    }
</script>